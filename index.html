<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">

    <title>Desert Strike: Dust Operations</title>

    <style>

        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; user-select: none; background: #000; }

        #game-ui { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }

        

        /* HUD Elements */

        #crosshair {

            position: absolute; top: 50%; left: 50%; width: 2px; height: 14px; background: #0f0; transform: translate(-50%, -50%);

            box-shadow: 0 0 2px #000;

        }

        #crosshair::after {

            content: ''; position: absolute; top: 50%; left: 50%; width: 14px; height: 2px; background: #0f0; transform: translate(-50%, -50%);

            box-shadow: 0 0 2px #000;

        }



        #health-bar {

            position: absolute; bottom: 30px; left: 30px; font-size: 32px; font-weight: bold; color: #fff;

            text-shadow: 2px 2px 0 #000; display: flex; align-items: center;

        }

        .icon-plus { color: #d32f2f; margin-right: 10px; }



        #ammo-display {

            position: absolute; bottom: 30px; right: 30px; font-size: 32px; font-weight: bold; color: #fff;

            text-shadow: 2px 2px 0 #000; display: flex; align-items: center;

        }

        .icon-bullet { color: #fbc02d; margin-right: 10px; }



        #score-board {

            position: absolute; top: 0; left: 50%; transform: translateX(-50%);

            background: rgba(0, 0, 0, 0.5); padding: 5px 20px; border-bottom-left-radius: 10px; border-bottom-right-radius: 10px;

            color: #fff; font-size: 20px; font-weight: bold; display: flex; gap: 20px;

            box-shadow: 0 2px 5px rgba(0,0,0,0.5);

        }

        .t-score { color: #ff9800; } /* Raiders */

        .ct-score { color: #448aff; } /* Guardians */



        #kill-feed {

            position: absolute; top: 20px; right: 20px; width: 300px; display: flex; flex-direction: column; align-items: flex-end; gap: 5px;

        }

        .kill-msg {

            background: rgba(0, 0, 0, 0.6); color: #fff; padding: 4px 10px; border-radius: 4px; font-size: 14px;

            animation: fadeOut 5s forwards; border-left: 3px solid #d32f2f;

        }

        

        /* CHAT UI */

        #chat-ui {

            position: absolute; bottom: 120px; left: 20px; width: 350px;

            display: flex; flex-direction: column; justify-content: flex-end;

            pointer-events: none; 

        }

        #chat-history {

            max-height: 200px; overflow-y: hidden; display: flex; flex-direction: column; gap: 4px;

            margin-bottom: 8px;

        }

        .chat-msg {

            background: rgba(0, 0, 0, 0.5); color: #fff; padding: 4px 8px; border-radius: 4px;

            font-size: 14px; text-shadow: 1px 1px 0 #000;

            animation: fadeOut 15s forwards; 

        }

        .chat-msg .name { font-weight: bold; margin-right: 5px; }

        .chat-msg .team-raider { color: #ff9800; }

        .chat-msg .team-guardian { color: #448aff; }

        

        #chat-input {

            background: rgba(0, 0, 0, 0.7); border: 1px solid #555; color: #fff; padding: 8px;

            font-size: 14px; border-radius: 4px; display: none; pointer-events: auto;

        }

        #chat-input:focus { outline: none; border-color: #fbc02d; }



        @keyframes fadeOut { 0% { opacity: 1; } 85% { opacity: 1; } 100% { opacity: 0; visibility: hidden; } }



        #damage-overlay {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%;

            background: radial-gradient(circle, transparent 50%, rgba(255, 0, 0, 0.6) 100%);

            opacity: 0; transition: opacity 0.1s; pointer-events: none;

        }



        #message-center {

            position: absolute; top: 20%; left: 50%; transform: translateX(-50%);

            font-size: 36px; font-weight: bold; color: #fff; text-shadow: 2px 2px 4px #000;

            text-align: center; opacity: 0; transition: opacity 0.3s;

        }



        /* Respawn UI */

        #respawn-ui {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%;

            background: rgba(100, 0, 0, 0.3);

            display: none; /* Hidden by default */

            flex-direction: column; justify-content: center; align-items: center;

            pointer-events: auto;

            z-index: 20;

        }

        #respawn-btn {

            background: #d32f2f; color: #fff; border: 2px solid #fff; padding: 15px 40px; font-size: 24px; cursor: pointer;

            font-weight: bold; text-transform: uppercase; border-radius: 5px; box-shadow: 0 5px 15px rgba(0,0,0,0.5);

        }

        #respawn-btn:hover { background: #b71c1c; }



        /* Start / Pause Screen */

        #start-screen {

            position: absolute; top: 0; left: 0; width: 100%; height: 100%;

            background: rgba(0, 0, 0, 0.85); display: flex; flex-direction: column;

            justify-content: center; align-items: center; color: #fff; z-index: 10;

        }

        h1 { font-size: 64px; margin: 0 0 20px 0; color: #fbc02d; text-transform: uppercase; letter-spacing: 5px; text-shadow: 4px 4px 0 #000; }

        .controls { margin-bottom: 40px; text-align: center; line-height: 1.6; font-size: 18px; color: #ccc; }

        .key { display: inline-block; background: #333; padding: 2px 8px; border-radius: 4px; border: 1px solid #555; color: #fff; font-weight: bold; }

        #play-btn {

            background: #d32f2f; color: #fff; border: none; padding: 15px 50px; font-size: 24px; cursor: pointer;

            font-weight: bold; text-transform: uppercase; border-radius: 5px; box-shadow: 0 5px 0 #b71c1c; transition: transform 0.1s, box-shadow 0.1s;

        }

        #play-btn:active { transform: translateY(5px); box-shadow: none; }

        

        #win-msg { font-size: 40px; color: #4caf50; margin-bottom: 20px; display: none; }

    </style>

</head>

<body>



    <!-- HUD -->

    <div id="game-ui">

        <div id="crosshair"></div>

        <div id="damage-overlay"></div>

        <div id="score-board">

            <span class="t-score">RAIDERS: <span id="score-t">0</span></span>

            <span id="timer">00:00</span>

            <span class="ct-score">GUARDIANS: <span id="score-ct">0</span></span>

        </div>

        <div id="message-center">ROUND START</div>

        <div id="kill-feed"></div>

        <div id="health-bar"><span class="icon-plus">+</span> <span id="hp-val">100</span></div>

        <div id="ammo-display"><span class="icon-bullet">▮▮▮</span> <span id="ammo-val">30</span> / <span id="reserve-val">90</span></div>

        

        <!-- Chat UI -->

        <div id="chat-ui">

            <div id="chat-history">

                <div class="chat-msg"><span class="name team-raider">System:</span> Press ENTER to chat</div>

            </div>

            <input type="text" id="chat-input" maxlength="60" placeholder="Say something...">

        </div>

    </div>



    <!-- Respawn Screen -->

    <div id="respawn-ui">

        <h2 style="color: #fff; font-size: 48px; text-shadow: 2px 2px 0 #000; margin-bottom: 20px;">YOU ARE DEAD</h2>

        <button id="respawn-btn">RESPAWN (SPACE)</button>

    </div>



    <!-- Start Screen -->

    <div id="start-screen">

        <h1>Dust Operations</h1>

        <div id="win-msg">MATCH WINNER DETERMINED</div>

        <div class="controls">

            <p><span class="key">W</span><span class="key">A</span><span class="key">S</span><span class="key">D</span> to Move</p>

            <p><span class="key">MOUSE</span> to Look</p>

            <p><span class="key">LMB</span> to Shoot &nbsp; | &nbsp; <span class="key">R</span> to Reload</p>

            <p><span class="key">ENTER</span> to Chat</p>

            <p>5 vs 5 Team Deathmatch</p>

        </div>

        <button id="play-btn">DEPLOY</button>

    </div>



    <!-- Three.js from CDN -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>



    <script>

        // =================================================================

        // CONFIG & GLOBALS

        // =================================================================

        const CONFIG = {

            fov: 75,

            mouseSens: 0.002,

            playerSpeed: 7,

            playerHeight: 1.7,

            playerRadius: 0.4,

            gravity: 15,

            jumpForce: 0,

            maxPitch: Math.PI * 0.44,

            roundsToWin: 6,

            botSpeed: 7.5, // Increased speed for rushing

            botDetectionRange: 65,

            botShootDelay: 0.25,

            botReactionTime: 0.4,

        };



        const WEAPON = {

            damage: 25,

            fireRate: 0.1, 

            magSize: 30,

            reserveMax: 90,

            reloadTime: 2.0,

            recoil: 0.05,

            range: 100

        };



        const TEAMS = {

            RAIDER: 'raider',

            GUARDIAN: 'guardian'

        };



        const BOT_NAMES = ["Viper", "Ghost", "Raptor", "Snake", "Wolf", "Eagle", "Cobra", "Hawk", "Bear", "Fox"];

        const BOT_MESSAGES = ["Enemy spotted!", "Need backup!", "Cover me!", "Sector clear.", "Moving out.", "Taking fire!", "Go go go!"];



        // Game State

        let state = {

            round: 1,

            scoreT: 0,

            scoreCT: 0,

            isRoundActive: false,

            isPaused: true,

            isChatting: false,

            player: null,

            entities: [],

            mapColliders: [],

            projectiles: [] 

        };



        // Three.js Globals

        let scene, camera, renderer, clock;

        let weaponGroup, weaponRecoil = { x: 0, z: 0, y: 0 };

        let muzzleFlash;

        let barrelEnd = new THREE.Vector3(); 

        

        // Input

        let move = { w: false, a: false, s: false, d: false };

        let isLocked = false;



        // Assets (Procedural Textures)

        const textures = {};



        // =================================================================

        // INIT & LOOP

        // =================================================================

        window.onload = init;



        function init() {

            scene = new THREE.Scene();

            scene.background = new THREE.Color(0x87CEEB);

            scene.fog = new THREE.Fog(0x87CEEB, 20, 60);



            camera = new THREE.PerspectiveCamera(CONFIG.fov, window.innerWidth / window.innerHeight, 0.1, 1000);

            camera.rotation.order = "YXZ";

            scene.add(camera);

            

            renderer = new THREE.WebGLRenderer({ antialias: true });

            renderer.setSize(window.innerWidth, window.innerHeight);

            renderer.shadowMap.enabled = true;

            document.body.appendChild(renderer.domElement);



            clock = new THREE.Clock();



            // Lighting

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);

            scene.add(ambientLight);



            const dirLight = new THREE.DirectionalLight(0xffdfba, 0.8);

            dirLight.position.set(50, 100, 50);

            dirLight.castShadow = true;

            dirLight.shadow.mapSize.width = 2048;

            dirLight.shadow.mapSize.height = 2048;

            dirLight.shadow.camera.near = 0.5;

            dirLight.shadow.camera.far = 200;

            dirLight.shadow.camera.left = -50;

            dirLight.shadow.camera.right = 50;

            dirLight.shadow.camera.top = 50;

            dirLight.shadow.camera.bottom = -50;

            scene.add(dirLight);



            generateTextures();

            buildMap();

            setupInput();

            animate();

            

            setInterval(botChatter, 8000);

        }



        function startGame() {

            document.getElementById('start-screen').style.display = 'none';

            document.getElementById('respawn-ui').style.display = 'none';

            document.getElementById('game-ui').style.display = 'block';

            document.body.requestPointerLock();

            state.isPaused = false;

            

            if (state.scoreT === 0 && state.scoreCT === 0) {

                startRound();

            }

        }



        function respawnPlayer() {

            if (!state.player) return;



            document.getElementById('respawn-ui').style.display = 'none';

            document.body.requestPointerLock();

            

            state.player.hp = 100;

            state.player.isAlive = true;

            state.player.ammo = WEAPON.magSize;

            state.player.reserve = WEAPON.reserveMax;

            

            state.player.position.set(0, 0, 40); // FIXED: Spawn on ground (y=0)

            state.player.velocity.set(0, 0, 0);



            camera.position.copy(state.player.position);

            camera.position.y += CONFIG.playerHeight;

            camera.rotation.set(0, 0, 0); 

            camera.rotation.x = 0;

            

            if (weaponGroup) {

                weaponGroup.visible = true;

                weaponGroup.rotation.x = 0;

            }



            showMessage("RESPAWNED", 1000);

        }



        function addChatMessage(name, msg, team) {

            const history = document.getElementById('chat-history');

            const line = document.createElement('div');

            line.className = 'chat-msg';

            const teamClass = team === TEAMS.RAIDER ? 'team-raider' : 'team-guardian';

            line.innerHTML = `<span class="name ${teamClass}">${name}:</span> ${msg}`;

            history.appendChild(line);

            history.scrollTop = history.scrollHeight;

            if (history.children.length > 8) history.removeChild(history.firstChild);

        }



        function toggleChat(open) {

            state.isChatting = open;

            const input = document.getElementById('chat-input');

            

            if (open) {

                document.exitPointerLock();

                input.style.display = 'block';

                setTimeout(() => input.focus(), 10); 

            } else {

                input.style.display = 'none';

                input.value = ''; 

                document.body.requestPointerLock();

            }

        }



        function botChatter() {

            if (!state.isRoundActive) return;

            const bots = state.entities.filter(e => !e.isPlayer && e.isAlive);

            if (bots.length === 0) return;

            

            if (Math.random() > 0.7) { 

                const bot = bots[Math.floor(Math.random() * bots.length)];

                const msg = BOT_MESSAGES[Math.floor(Math.random() * BOT_MESSAGES.length)];

                const name = BOT_NAMES[Math.floor(Math.random() * BOT_NAMES.length)];

                addChatMessage(name, msg, bot.team);

            }

        }



        function generateTextures() {

            function createCanvasTexture(width, height, drawFn) {

                const canvas = document.createElement('canvas');

                canvas.width = width;

                canvas.height = height;

                const ctx = canvas.getContext('2d');

                drawFn(ctx, width, height);

                const tex = new THREE.CanvasTexture(canvas);

                tex.wrapS = THREE.RepeatWrapping;

                tex.wrapT = THREE.RepeatWrapping;

                return tex;

            }



            textures.sand = createCanvasTexture(512, 512, (ctx, w, h) => {

                ctx.fillStyle = '#C2B280';

                ctx.fillRect(0, 0, w, h);

                for(let i=0; i<5000; i++) {

                    ctx.fillStyle = Math.random() > 0.5 ? '#d4c490' : '#b0a070';

                    ctx.fillRect(Math.random()*w, Math.random()*h, 2, 2);

                }

            });



            textures.wall = createCanvasTexture(512, 512, (ctx, w, h) => {

                ctx.fillStyle = '#dcb';

                ctx.fillRect(0, 0, w, h);

                ctx.strokeStyle = '#a98';

                ctx.lineWidth = 3;

                const brickH = 64;

                const brickW = 128;

                for(let y=0; y<h; y+=brickH) {

                    const offset = (y/brickH % 2) * (brickW/2);

                    for(let x=-brickW; x<w; x+=brickW) {

                        ctx.strokeRect(x + offset, y, brickW, brickH);

                        if(Math.random() > 0.7) {

                            ctx.fillStyle = 'rgba(100,80,60,0.1)';

                            ctx.fillRect(x + offset + 5, y + 5, brickW-10, brickH-10);

                        }

                    }

                }

                ctx.font = 'bold 40px Arial';

                ctx.fillStyle = 'rgba(200, 50, 50, 0.4)';

                ctx.save();

                ctx.translate(w/2, h/2);

                ctx.rotate(-0.2);

                ctx.fillText("DUST", -50, 0);

                ctx.restore();

            });



            textures.crate = createCanvasTexture(256, 256, (ctx, w, h) => {

                ctx.fillStyle = '#8b5a2b';

                ctx.fillRect(0, 0, w, h);

                ctx.strokeStyle = '#5c3a1a';

                ctx.lineWidth = 10;

                ctx.strokeRect(0,0,w,h);

                ctx.beginPath();

                ctx.moveTo(0,0); ctx.lineTo(w,h);

                ctx.moveTo(w,0); ctx.lineTo(0,h);

                ctx.stroke();

            });



            textures.camo = createCanvasTexture(256, 256, (ctx, w, h) => {

                ctx.fillStyle = '#3a3a3a'; 

                ctx.fillRect(0,0,w,h);

                const colors = ['#4b5320', '#8b4513', '#1a1a1a'];

                for(let i=0; i<30; i++) {

                    ctx.fillStyle = colors[Math.floor(Math.random()*colors.length)];

                    ctx.beginPath();

                    ctx.arc(Math.random()*w, Math.random()*h, 20 + Math.random()*40, 0, Math.PI*2);

                    ctx.fill();

                }

            });

        }



        function buildMap() {

            const matSand = new THREE.MeshStandardMaterial({ map: textures.sand, roughness: 1 });

            const matWall = new THREE.MeshStandardMaterial({ map: textures.wall, roughness: 0.8 });

            const matCrate = new THREE.MeshStandardMaterial({ map: textures.crate });



            const groundGeo = new THREE.PlaneGeometry(100, 100);

            textures.sand.repeat.set(20, 20);

            const ground = new THREE.Mesh(groundGeo, matSand);

            ground.rotation.x = -Math.PI / 2;

            ground.receiveShadow = true;

            scene.add(ground);



            function addBox(x, y, z, w, h, d, type='wall') {

                const geo = new THREE.BoxGeometry(w, h, d);

                let mat = type === 'wall' ? matWall : matCrate;

                const mesh = new THREE.Mesh(geo, mat);

                mesh.position.set(x, y + h/2, z);

                mesh.castShadow = true;

                mesh.receiveShadow = true;

                scene.add(mesh);

                

                const box = new THREE.Box3().setFromObject(mesh);

                state.mapColliders.push({ box: box, mesh: mesh });

            }



            // Map Layout

            addBox(0, 0, -50, 100, 10, 2); 

            addBox(0, 0, 50, 100, 10, 2); 

            addBox(-50, 0, 0, 2, 10, 100); 

            addBox(50, 0, 0, 2, 10, 100); 



            addBox(-10, 0, 0, 2, 6, 40); 

            addBox(10, 0, 0, 2, 6, 40); 



            addBox(0, 0, -30, 10, 3, 10, 'crate'); 

            addBox(-20, 0, -35, 4, 4, 4, 'crate');

            addBox(20, 0, -35, 4, 4, 4, 'crate');



            addBox(-30, 0, 20, 10, 4, 2); 

            addBox(30, 0, 20, 10, 4, 2);



            addBox(5, 0, 10, 2, 2, 2, 'crate');

            addBox(-5, 0, -10, 2, 2, 2, 'crate');

            addBox(15, 0, -5, 3, 3, 3, 'crate');



            addBox(0, 6, 0, 22, 2, 2); 

        }



        class Entity {

            constructor(team, isPlayer = false, id = 0) {

                this.team = team;

                this.isPlayer = isPlayer;

                this.id = id;

                this.hp = 100;

                this.isAlive = true;

                this.mesh = null;

                this.position = new THREE.Vector3();

                this.velocity = new THREE.Vector3();

                

                this.ammo = WEAPON.magSize;

                this.reserve = WEAPON.reserveMax;

                this.lastShotTime = 0;

                this.isReloading = false;

                this.weaponReloadStage = 0;



                // AI Props

                this.state = 'PATROL';

                this.target = null;

                this.waypoints = [];

                this.currentWaypointIdx = 0;

                this.strafeDir = 1;

                this.strafeTimer = 0;

                this.stuckTimer = 0; // NEW: Detect stuck

                this.lastPos = new THREE.Vector3();

            }



            spawn(pos) {

                this.hp = 100;

                this.isAlive = true;

                this.isReloading = false;

                this.ammo = WEAPON.magSize;

                this.position.copy(pos);

                this.velocity.set(0,0,0);

                this.stuckTimer = 0;



                if (this.isPlayer) {

                    camera.position.copy(this.position);

                    camera.position.y += CONFIG.playerHeight;

                    camera.rotation.set(0, 0, 0);

                    if(weaponGroup) {

                        weaponGroup.visible = true;

                        weaponGroup.rotation.x = 0;

                    }

                } else {

                    if (this.mesh) {

                        this.mesh.visible = true;

                        this.mesh.position.copy(this.position);

                        this.state = 'PATROL';

                        this.generateWaypoints();

                    }

                }

            }



            die() {

                this.isAlive = false;

                if (this.isPlayer) {

                    document.exitPointerLock();

                    document.getElementById('respawn-ui').style.display = 'flex';

                    if(weaponGroup) weaponGroup.visible = false;

                } else {

                    if(this.mesh) this.mesh.visible = false; 

                }

                checkRoundEnd();

            }



            generateWaypoints() {

                // Generate Safe waypoints within main corridor X range (-10 to 10)

                this.waypoints = [];

                for(let i=0; i<4; i++) {

                    let z = (Math.random() - 0.5) * 80;

                    let x = (Math.random() - 0.5) * 16; // Keep in center corridor (-8 to 8)

                    this.waypoints.push(new THREE.Vector3(x, 0, z));

                }

            }

        }



        function createBotMesh(team) {

            const group = new THREE.Group();

            

            const matBody = new THREE.MeshStandardMaterial({ 

                color: team === TEAMS.GUARDIAN ? 0x333333 : 0x665544,

                map: team === TEAMS.GUARDIAN ? textures.camo : null

            });

            const matSkin = new THREE.MeshStandardMaterial({ color: 0xffccaa });

            const matPants = new THREE.MeshStandardMaterial({ color: team === TEAMS.GUARDIAN ? 0x1a2b1a : 0x223344 });



            const legGeo = new THREE.BoxGeometry(0.5, 0.8, 0.5);

            const leftLeg = new THREE.Mesh(legGeo, matPants);

            leftLeg.position.set(-0.3, 0.4, 0);

            const rightLeg = new THREE.Mesh(legGeo, matPants);

            rightLeg.position.set(0.3, 0.4, 0);

            group.add(leftLeg, rightLeg);



            const torsoGeo = new THREE.BoxGeometry(1.2, 1.0, 0.6);

            const torso = new THREE.Mesh(torsoGeo, matBody);

            torso.position.set(0, 1.3, 0);

            group.add(torso);



            const headGeo = new THREE.BoxGeometry(0.4, 0.5, 0.4);

            const headMat = team === TEAMS.GUARDIAN ? matBody : matSkin; 

            const head = new THREE.Mesh(headGeo, headMat);

            head.position.set(0, 2.15, 0);

            group.add(head);



            const gunGroup = new THREE.Group();

            const gunBody = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.8), new THREE.MeshStandardMaterial({color: 0x111111}));

            gunGroup.add(gunBody);

            gunGroup.position.set(0.4, 1.4, 0.5);

            group.add(gunGroup);



            return group;

        }



        function createPlayerWeapon() {

            if (weaponGroup) camera.remove(weaponGroup);



            weaponGroup = new THREE.Group();

            weaponGroup.scale.set(1.5, 1.5, 1.5);

            weaponGroup.renderOrder = 999;

            

            const matSettings = { depthTest: false, depthWrite: false };

            const matMetal = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.3, metalness: 0.8, ...matSettings });

            const matPlastic = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, ...matSettings });

            

            // --- Weapon Model (No Arms) ---

            const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.4), matMetal);

            receiver.renderOrder = 999;

            weaponGroup.add(receiver);



            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.5), matMetal);

            barrel.renderOrder = 999;

            barrel.rotation.x = -Math.PI/2;

            barrel.position.z = -0.45;

            weaponGroup.add(barrel);

            

            const silencer = new THREE.Mesh(new THREE.CylinderGeometry(0.035, 0.035, 0.4), matMetal);

            silencer.renderOrder = 999;

            silencer.rotation.x = -Math.PI/2;

            silencer.position.z = -0.8; 

            weaponGroup.add(silencer);



            const barrelEndMesh = new THREE.Object3D();

            barrelEndMesh.position.set(0, 0, -1.0); 

            weaponGroup.add(barrelEndMesh);

            weaponGroup.userData.barrelEnd = barrelEndMesh;



            const handguard = new THREE.Mesh(new THREE.BoxGeometry(0.09, 0.09, 0.35), matPlastic);

            handguard.renderOrder = 999;

            handguard.position.z = -0.3;

            weaponGroup.add(handguard);



            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.25, 0.1), matMetal);

            mag.renderOrder = 999;

            mag.position.set(0, -0.15, 0);

            mag.rotation.x = 0.2;

            weaponGroup.add(mag);

            weaponGroup.userData.magazine = mag;



            const stock = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.12, 0.3), matPlastic);

            stock.renderOrder = 999;

            stock.position.set(0, -0.05, 0.35);

            weaponGroup.add(stock);



            const handle = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.06, 0.2), matMetal);

            handle.renderOrder = 999;

            handle.position.set(0, 0.08, -0.05);

            weaponGroup.add(handle);



            const fSight = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.06, 0.02), matMetal);

            fSight.renderOrder = 999;

            fSight.position.set(0, 0.05, -0.45);

            weaponGroup.add(fSight);



            // Removed Arms Here



            weaponGroup.position.set(0.3, -0.3, -0.6); 

            camera.add(weaponGroup);



            muzzleFlash = new THREE.PointLight(0xffffaa, 0, 5);

            muzzleFlash.position.set(0, 0.05, -1.1);

            weaponGroup.add(muzzleFlash);

        }



        function createTracer(startPos, endPos) {

            const distance = startPos.distanceTo(endPos);

            const geometry = new THREE.CylinderGeometry(0.02, 0.02, distance, 6);

            geometry.rotateX(-Math.PI / 2);

            const material = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.8 });

            const mesh = new THREE.Mesh(geometry, material);

            const midPoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);

            mesh.position.copy(midPoint);

            mesh.lookAt(endPos);

            scene.add(mesh);

            state.projectiles.push({ mesh: mesh, age: 0 });

        }



        function startRound() {

            state.isRoundActive = false;

            state.round++;

            showMessage(`ROUND ${state.round}`, 2000);

            updateHUD();



            state.entities.forEach(e => {

                if(e.mesh) scene.remove(e.mesh);

            });

            state.entities = [];

            state.projectiles.forEach(p => scene.remove(p.mesh));

            state.projectiles = [];



            // 1. Player (Raider)

            state.player = new Entity(TEAMS.RAIDER, true, 0);

            state.entities.push(state.player);

            state.player.spawn(new THREE.Vector3(0, 0, 40)); // FIXED: Spawn on ground (y=0)

            

            // 2. Raiders (4 allies -> 5 total)

            for(let i=0; i<4; i++) {

                const bot = new Entity(TEAMS.RAIDER, false, i + 1);

                bot.mesh = createBotMesh(TEAMS.RAIDER);

                scene.add(bot.mesh);

                state.entities.push(bot);

                // Spread out spawn

                bot.spawn(new THREE.Vector3(-12 + i*6, 0, 44)); // FIXED: Spawn on ground

            }



            // 3. Guardians (5 enemies)

            for(let i=0; i<5; i++) {

                const bot = new Entity(TEAMS.GUARDIAN, false, i + 10);

                bot.mesh = createBotMesh(TEAMS.GUARDIAN);

                scene.add(bot.mesh);

                state.entities.push(bot);

                // Spread out spawn

                bot.spawn(new THREE.Vector3(-12 + i*6, 0, -44)); // FIXED: Spawn on ground

            }



            createPlayerWeapon();

            weaponGroup.visible = true;



            setTimeout(() => {

                state.isRoundActive = true;

                showMessage("GO! GO! GO!", 1000);

            }, 2000);

        }



        function checkRoundEnd() {

            const raidersAlive = state.entities.filter(e => e.team === TEAMS.RAIDER && e.isAlive).length;

            const guardiansAlive = state.entities.filter(e => e.team === TEAMS.GUARDIAN && e.isAlive).length;



            if (raidersAlive === 0 || guardiansAlive === 0) {

                if (!state.isRoundActive) return;

                state.isRoundActive = false;

                

                let winner = raidersAlive > 0 ? 'RAIDERS' : 'GUARDIANS';

                if (winner === 'RAIDERS') state.scoreT++; else state.scoreCT++;

                

                showMessage(`${winner} WIN`, 3000);

                

                if (state.scoreT >= CONFIG.roundsToWin || state.scoreCT >= CONFIG.roundsToWin) {

                    setTimeout(() => {

                        document.getElementById('win-msg').innerText = `${winner} WIN THE MATCH`;

                        document.getElementById('win-msg').style.display = 'block';

                        document.getElementById('start-screen').style.display = 'flex';

                        document.exitPointerLock();

                        state.isPaused = true;

                        state.scoreT = 0;

                        state.scoreCT = 0;

                        state.round = 0;

                    }, 3000);

                } else {

                    setTimeout(startRound, 3000);

                }

            }

        }



        function animate() {

            requestAnimationFrame(animate);

            if (state.isPaused) return;



            const dt = clock.getDelta();

            const now = clock.getElapsedTime();



            if (state.isRoundActive && state.player) {

                updatePlayer(dt, now);

            }



            if (state.isRoundActive) {

                updateBots(dt, now);

            }



            for (let i = state.projectiles.length - 1; i >= 0; i--) {

                const p = state.projectiles[i];

                p.age += dt;

                if (p.age > 0.05) { 

                    scene.remove(p.mesh);

                    state.projectiles.splice(i, 1);

                } else {

                    p.mesh.material.opacity = 1 - (p.age / 0.05);

                }

            }



            updateWeaponAnimation(dt);

            updateHUD();

            renderer.render(scene, camera);

        }



        function updatePlayer(dt, now) {

            if (state.isChatting) return;



            if (state.player.isAlive) {

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

                forward.y = 0; forward.normalize();

                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

                right.y = 0; right.normalize();



                const velocity = new THREE.Vector3();

                if (move.w) velocity.add(forward);

                if (move.s) velocity.sub(forward);

                if (move.d) velocity.add(right);

                if (move.a) velocity.sub(right);



                if (velocity.lengthSq() > 0) velocity.normalize().multiplyScalar(CONFIG.playerSpeed * dt);



                resolveCollision(state.player, velocity);



                camera.position.copy(state.player.position);

                camera.position.y += CONFIG.playerHeight;

            } else {

                camera.position.y = THREE.MathUtils.lerp(camera.position.y, 0.5, dt * 5);

                camera.rotation.z = THREE.MathUtils.lerp(camera.rotation.z, -Math.PI / 3, dt * 2);

            }

        }



        function updateBots(dt, now) {

            state.entities.forEach(bot => {

                if (bot.isPlayer || !bot.isAlive) return;



                let target = null;

                let minDist = CONFIG.botDetectionRange;



                // Scan for targets

                state.entities.forEach(other => {

                    if (other.isAlive && other.team !== bot.team) {

                        const dist = bot.position.distanceTo(other.position);

                        if (dist < minDist) {

                            if (checkLineOfSight(bot.position, other.position)) {

                                minDist = dist;

                                target = other;

                            }

                        }

                    }

                });



                bot.target = target;

                if (bot.target) bot.state = 'ATTACK';

                else bot.state = 'PATROL';



                const moveVec = new THREE.Vector3();



                // STUCK CHECK

                const moveDist = bot.position.distanceTo(bot.lastPos);

                bot.lastPos.copy(bot.position);

                if (moveDist < 0.01) {

                    bot.stuckTimer += dt;

                    if (bot.stuckTimer > 1.0) {

                        // Unstick: Pick a new waypoint or jump

                        bot.generateWaypoints(); 

                        moveVec.add(new THREE.Vector3(Math.random()-0.5, 0, Math.random()-0.5).multiplyScalar(2));

                        bot.stuckTimer = 0;

                    }

                } else {

                    bot.stuckTimer = 0;

                }



                // Push out of walls logic (Force separation from map geometry)

                if(checkCollision(bot.position)) {

                    // Simple push towards center (0,0,0)

                    const pushDir = new THREE.Vector3().subVectors(new THREE.Vector3(0,0,0), bot.position).normalize();

                    moveVec.add(pushDir.multiplyScalar(2.0)); // Force push

                }



                if (bot.state === 'ATTACK') {

                    const targetPos = bot.target.position;

                    const dx = targetPos.x - bot.position.x;

                    const dz = targetPos.z - bot.position.z;

                    const targetAngle = Math.atan2(dx, dz);

                    

                    let diff = targetAngle - bot.mesh.rotation.y;

                    while (diff > Math.PI) diff -= Math.PI * 2;

                    while (diff < -Math.PI) diff += Math.PI * 2;

                    bot.mesh.rotation.y += diff * dt * 5;



                    bot.strafeTimer += dt;

                    if (bot.strafeTimer > 1.5) {

                        bot.strafeDir = Math.random() > 0.5 ? 1 : -1;

                        bot.strafeTimer = 0;

                    }



                    const dirToEnemy = new THREE.Vector3(dx, 0, dz).normalize();

                    const rightVec = new THREE.Vector3().crossVectors(dirToEnemy, new THREE.Vector3(0,1,0)).normalize();

                    moveVec.add(rightVec.multiplyScalar(bot.strafeDir * CONFIG.botSpeed * 0.6));



                    const dist = bot.position.distanceTo(targetPos);

                    if (dist > 25) {

                        moveVec.add(dirToEnemy.multiplyScalar(CONFIG.botSpeed * 0.8));

                    } else if (dist < 8) {

                        moveVec.add(dirToEnemy.multiplyScalar(-CONFIG.botSpeed * 0.8));

                    }



                    if (now - bot.lastShotTime > CONFIG.botShootDelay) {

                        if (Math.random() < 0.9) shoot(bot, now);

                    }

                } 

                else if (bot.state === 'PATROL') {

                    // FIXED: Removed extra dt multiplication

                    if (bot.waypoints.length > 0) {

                        const wp = bot.waypoints[bot.currentWaypointIdx];

                        const dir = new THREE.Vector3().subVectors(wp, bot.position);

                        dir.y = 0;

                        const dist = dir.length();

                        

                        if (dist < 1.5) { // Reached waypoint

                            bot.currentWaypointIdx = (bot.currentWaypointIdx + 1) % bot.waypoints.length;

                        } else {

                            dir.normalize();

                            moveVec.copy(dir).multiplyScalar(CONFIG.botSpeed); // FIXED: Removed * dt here

                            const angle = Math.atan2(dir.x, dir.z);

                            let diff = angle - bot.mesh.rotation.y;

                            while (diff > Math.PI) diff -= Math.PI * 2;

                            while (diff < -Math.PI) diff += Math.PI * 2;

                            bot.mesh.rotation.y += diff * dt * 5;

                        }

                    }

                }



                state.entities.forEach(other => {

                    if (other !== bot && other.isAlive) {

                        const dist = bot.position.distanceTo(other.position);

                        if (dist < 2.0) {

                            const pushDir = new THREE.Vector3().subVectors(bot.position, other.position).normalize();

                            moveVec.add(pushDir.multiplyScalar(4.0 * dt)); // Keep dt here as force depends on time? No, actually force should be acceleration.

                            // But for simple movement logic, adding displacement is okay if small.

                        }

                    }

                });



                // Apply velocity * dt

                resolveCollision(bot, moveVec.multiplyScalar(dt)); 

                

                bot.mesh.position.copy(bot.position);

                // IMPORTANT: Mesh pivot is at feet? createBotMesh legs are at y=0.4 (height 0.8).

                // So if bot.position.y is 0, legs center is 0.4. Bottom of legs is 0.

                // So we do NOT add offset if spawn is 0.

                // Actually, let's keep slight offset to avoid Z-fighting with floor

                bot.mesh.position.y = 0.05; 

            });

        }



        // IMPROVED COLLISION: Sliding along walls

        function resolveCollision(entity, velocity) {

            // Try full move

            let testPos = entity.position.clone().add(velocity);

            if (!checkCollision(testPos)) {

                entity.position.copy(testPos);

                return;

            }



            // Try X only (Slide along Z)

            testPos = entity.position.clone().add(new THREE.Vector3(velocity.x, 0, 0));

            if (!checkCollision(testPos)) {

                entity.position.x = testPos.x;

            }



            // Try Z only (Slide along X)

            testPos = entity.position.clone().add(new THREE.Vector3(0, 0, velocity.z));

            if (!checkCollision(testPos)) {

                entity.position.z = testPos.z;

            }

            

            // Clamp map bounds

            entity.position.x = Math.max(-48, Math.min(48, entity.position.x));

            entity.position.z = Math.max(-48, Math.min(48, entity.position.z));

        }



        function checkCollision(pos) {

            const playerBox = new THREE.Box3();

            const size = 0.6;

            playerBox.setFromCenterAndSize(

                new THREE.Vector3(pos.x, pos.y + 1, pos.z), 

                new THREE.Vector3(size, 2, size)

            );



            for (let collider of state.mapColliders) {

                if (playerBox.intersectsBox(collider.box)) {

                    return true;

                }

            }

            return false;

        }



        // ... (shoot, reload, checkLineOfSight, updateWeaponAnimation, HUD, Input - same as before) ...

        function shoot(shooter, time) {

            if (!shooter.isAlive) return; 

            if (shooter.isPlayer && state.isChatting) return;



            if (shooter.ammo <= 0) {

                reload(shooter);

                return;

            }



            shooter.ammo--;

            shooter.lastShotTime = time;



            const raycaster = new THREE.Raycaster();

            let origin, dir;

            let tracerStart;



            if (shooter.isPlayer) {

                origin = camera.position.clone();

                dir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);

                weaponRecoil.z += 0.2; 

                weaponRecoil.x += (Math.random() - 0.5) * 0.1;

                weaponRecoil.y += 0.05;

                muzzleFlash.intensity = 8;

                setTimeout(() => muzzleFlash.intensity = 0, 50);



                if(weaponGroup && weaponGroup.userData.barrelEnd) {

                    tracerStart = new THREE.Vector3();

                    weaponGroup.userData.barrelEnd.getWorldPosition(tracerStart);

                } else {

                    tracerStart = origin.clone().add(new THREE.Vector3(0.2, -0.2, -0.5).applyQuaternion(camera.quaternion));

                }

            } else {

                origin = shooter.position.clone().add(new THREE.Vector3(0, 1.5, 0));

                tracerStart = origin.clone().add(new THREE.Vector3(0, 0, 0.5)); 

                const targetPos = shooter.target.position.clone().add(new THREE.Vector3(0, 1.2, 0));

                targetPos.x += (Math.random() - 0.5) * 0.5;

                targetPos.z += (Math.random() - 0.5) * 0.5;

                dir = new THREE.Vector3().subVectors(targetPos, origin).normalize();

            }



            raycaster.set(origin, dir);



            const mapIntersects = raycaster.intersectObjects(state.mapColliders.map(c => c.mesh));

            let hitDist = Infinity;

            let hitPoint = null;



            if (mapIntersects.length > 0) {

                hitDist = mapIntersects[0].distance;

                hitPoint = mapIntersects[0].point;

            } else {

                hitPoint = origin.clone().add(dir.multiplyScalar(100));

            }



            const potentialTargets = state.entities.filter(e => e !== shooter && e.isAlive && e.team !== shooter.team);

            let hitEntity = null;

            let minEntDist = Infinity;



            potentialTargets.forEach(ent => {

                const pt = new THREE.Vector3().copy(ent.position).add(new THREE.Vector3(0,1,0));

                const rayPt = new THREE.Vector3();

                raycaster.ray.closestPointToPoint(pt, rayPt);

                const distToRay = pt.distanceTo(rayPt);

                const distFromShooter = origin.distanceTo(rayPt);



                if (distToRay < 0.6 && distFromShooter < hitDist) {

                    if (distFromShooter < minEntDist) {

                        minEntDist = distFromShooter;

                        hitEntity = ent;

                    }

                }

            });



            if (hitEntity) {

                hitPoint = origin.clone().add(dir.multiplyScalar(minEntDist));

                let dmg = WEAPON.damage;

                if (hitEntity.isPlayer) dmg *= 0.4;



                hitEntity.hp -= dmg;

                if (hitEntity.isPlayer) {

                    document.getElementById('damage-overlay').style.opacity = 0.8;

                    setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 300);

                }

                

                if (hitEntity.hp <= 0) {

                    const kName = shooter.isPlayer ? "Player" : "Bot";

                    const vName = hitEntity.isPlayer ? "Player" : "Bot";

                    killLog(kName, vName, shooter.team);

                    hitEntity.die();

                }

            }



            if (tracerStart && hitPoint) {

                createTracer(tracerStart, hitPoint);

            }

        }



        function reload(entity) {

            if (entity.isReloading || entity.reserve <= 0 || entity.ammo === WEAPON.magSize) return;

            entity.isReloading = true;

            

            if (entity.isPlayer) {

                showMessage("RELOADING...", 1000);

                entity.weaponReloadStage = 1;

                setTimeout(() => { entity.weaponReloadStage = 2; }, 500);

                setTimeout(() => {

                    const needed = WEAPON.magSize - entity.ammo;

                    const take = Math.min(needed, entity.reserve);

                    entity.ammo += take;

                    entity.reserve -= take;

                    entity.weaponReloadStage = 3;

                }, 1200);

                setTimeout(() => {

                    entity.isReloading = false;

                    entity.weaponReloadStage = 0;

                }, 1800);

            } else {

                setTimeout(() => {

                    entity.isReloading = false;

                    entity.ammo = WEAPON.magSize;

                }, 1500);

            }

        }



        function checkLineOfSight(p1, p2) {

            const dir = new THREE.Vector3().subVectors(p2, p1).normalize();

            const dist = p1.distanceTo(p2);

            const ray = new THREE.Raycaster(p1.clone().add(new THREE.Vector3(0,1.5,0)), dir, 0, dist);

            const hits = ray.intersectObjects(state.mapColliders.map(c => c.mesh));

            return hits.length === 0;

        }



        function updateWeaponAnimation(dt) {

            if (!weaponGroup || !state.player.isAlive) return;



            weaponRecoil.z = THREE.MathUtils.lerp(weaponRecoil.z, 0, dt * 15);

            weaponRecoil.x = THREE.MathUtils.lerp(weaponRecoil.x, 0, dt * 15);

            weaponRecoil.y = THREE.MathUtils.lerp(weaponRecoil.y, 0, dt * 15);



            const time = clock.getElapsedTime();

            let bobX = 0, bobY = 0;

            if ((move.w || move.a || move.s || move.d) && state.player.isAlive && !state.player.isReloading && !state.isChatting) {

                bobX = Math.cos(time * 10) * 0.015;

                bobY = Math.sin(time * 20) * 0.015;

            }



            let reloadRotX = 0;

            let reloadPosX = 0;

            let reloadPosY = 0;

            const mag = weaponGroup.userData.magazine;



            if (state.player.isReloading) {

                switch(state.player.weaponReloadStage) {

                    case 1: 

                        reloadRotX = THREE.MathUtils.lerp(weaponGroup.rotation.x, 0.5, dt * 10);

                        reloadPosY = THREE.MathUtils.lerp(weaponGroup.position.y, -0.3, dt * 10);

                        break;

                    case 2: 

                        if (mag) mag.visible = false;

                        reloadRotX = 0.5;

                        break;

                    case 3: 

                        if (mag) mag.visible = true;

                        reloadRotX = THREE.MathUtils.lerp(weaponGroup.rotation.x, 0, dt * 10);

                        reloadPosY = THREE.MathUtils.lerp(weaponGroup.position.y, -0.25, dt * 10);

                        break;

                }

                weaponGroup.rotation.x = reloadRotX;

            } else {

                if (mag) mag.visible = true;

                weaponGroup.rotation.x = THREE.MathUtils.lerp(weaponGroup.rotation.x, 0, dt * 10);

            }



            weaponGroup.position.set(

                0.3 + weaponRecoil.x + bobX + reloadPosX, 

                -0.3 + bobY + reloadPosY + weaponRecoil.y, 

                -0.6 + weaponRecoil.z

            );

        }



        function updateHUD() {

            if (state.player) {

                document.getElementById('hp-val').innerText = Math.max(0, Math.ceil(state.player.hp));

                document.getElementById('ammo-val').innerText = state.player.ammo;

                document.getElementById('reserve-val').innerText = state.player.reserve;

            }

            document.getElementById('score-t').innerText = state.scoreT;

            document.getElementById('score-ct').innerText = state.scoreCT;

        }



        function showMessage(text, duration) {

            const el = document.getElementById('message-center');

            el.innerText = text;

            el.style.opacity = 1;

            setTimeout(() => el.style.opacity = 0, duration);

        }



        function killLog(killer, victim, team) {

            const feed = document.getElementById('kill-feed');

            const msg = document.createElement('div');

            msg.className = 'kill-msg';

            const color = team === TEAMS.RAIDER ? '#ff9800' : '#448aff';

            msg.style.borderLeftColor = color;

            msg.innerHTML = `<span style="color:${color}">${killer}</span> 🔫 ${victim}`;

            feed.prepend(msg);

            if (feed.children.length > 5) feed.removeChild(feed.lastChild);

        }



        function setupInput() {

            document.addEventListener('keydown', (e) => {

                if (e.code === 'Enter') {

                    if (state.isChatting) {

                        const input = document.getElementById('chat-input');

                        const text = input.value.trim();

                        if (text) {

                            addChatMessage('Me', text, TEAMS.RAIDER);

                        }

                        toggleChat(false);

                    } else {

                        toggleChat(true);

                    }

                    return; 

                }



                if (state.isChatting) return; 



                if (e.code === 'Space' && state.player && !state.player.isAlive) {

                    respawnPlayer();

                    return;

                }



                switch(e.key.toLowerCase()) {

                    case 'w': move.w = true; break;

                    case 'a': move.a = true; break;

                    case 's': move.s = true; break;

                    case 'd': move.d = true; break;

                    case 'r': if(state.player && state.player.isAlive) reload(state.player); break;

                }

            });



            document.addEventListener('keyup', (e) => {

                switch(e.key.toLowerCase()) {

                    case 'w': move.w = false; break;

                    case 'a': move.a = false; break;

                    case 's': move.s = false; break;

                    case 'd': move.d = false; break;

                }

            });



            document.addEventListener('mousemove', (e) => {

                if (isLocked && !state.isChatting) {

                    camera.rotation.y -= e.movementX * CONFIG.mouseSens;

                    camera.rotation.x -= e.movementY * CONFIG.mouseSens;

                    camera.rotation.x = Math.max(-CONFIG.maxPitch, Math.min(CONFIG.maxPitch, camera.rotation.x));

                }

            });



            document.addEventListener('mousedown', (e) => {

                if (state.isChatting) return;



                if (isLocked && state.player && state.player.isAlive && e.button === 0) {

                    shoot(state.player, clock.getElapsedTime());

                }

            });



            document.addEventListener('pointerlockchange', () => {

                isLocked = (document.pointerLockElement === document.body);

            });



            document.getElementById('play-btn').addEventListener('click', startGame);

            document.getElementById('respawn-btn').addEventListener('click', respawnPlayer);

        }



        window.addEventListener('resize', () => {

            camera.aspect = window.innerWidth / window.innerHeight;

            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        });



    </script>

</body>

</html> 
